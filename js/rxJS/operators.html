<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>操作符</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.5/Rx.min.js"></script>
</head>
<body>
    <button id="bt">button</button>
</body>

<script>

////　操作符

// function multiplyByTen(input) {
// var output =Rx.Observable.create(function(observer){
//     input.subscribe({
//         next: (v) => observer.next(10*v),
//         error: (err) => observer.error(err),
//         complete: () => observer.complete()
//     });
// });
// return output;
// } 
// var input = Rx.Observable.from([1,2,3,4]);
// var output = multiplyByTen(input);
// output.subscribe(x=>console.log(x));

// output的订阅导致了作为输入的可观察对象也被订阅,这叫"操作符的订阅链"。

//// 实例操作符(instance operator)VS静态操作符(static operator)

// 实例操作符是使用this关键词来推演出"输入可观察对象"
// Rx.Observable.prototype.multiplyByTen = function(){
//     var input=this;
//     return Rx.Observable.create(function subscribe(observer){
//         input.subscribe({
//             next: (v) => observer.next(10*v),
//             error: (err) => observer.error(err),
//             complete: () => observer.complete()
//         });
//     });
// }
// 注意input并不是作为函数的参数，而是作为this所指代的那个对象
// var observable = Rx.Observable.from([1,2,3,4]).multiplyByTen();
// observable.subscribe(x => console.log(x));

// 不同于实例操作符，静态操作符是直接定义在类上的。一个静态操作符并不在其内部使用this，而是完全依赖于它的参数。
// 最常规的静态操作符是被称作构造操作符,它们仅接收一个非可观察对象作为参数，比如一个数字，然后构造出一个可观察对象
// var observable1 = Rx.Observable.intervable(1000); //1000毫秒
// var merged = Rx.Observable.merge(observable1, observable2);
// 静态操作符有: intervable，create，merge,combineLatest,concat等等
</script>
</html>