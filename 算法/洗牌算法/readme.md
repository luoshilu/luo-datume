# 洗牌算法

描述: 用来将一个有限集合生成一个随机排列的算法（数组随机排序）。这个算法生成的随机排列是等概率的。同时这个算法非常高效。

## 原始版

shuffle 的原始版本，最初描述在 1938 年的 Ronald Fisher（上图） 和 Frank Yates 写的书中，书名为《Statistical tables for biological, agricultural and medical research》。他们使用纸和笔去描述了这个算法，并使用了一个随机数表来提供随机数。它给出了 1 到 N 的数字的的随机排列。步骤如下:

1. 写下从 1 到 N 的数字
2. 取一个从 1 到剩下的数字（包括这个数字）的随机数 k
3. 从低位开始，得到第 k 个数字（这个数字还没有被取出），把它写在独立的一个列表的最后一位
4. 重复第 2 步，直到所有的数字都被取出
5. 第 3 步写出的这个序列，现在就是原始数字的随机排列

## 现代版

现代版的洗牌算法是为了计算机进行设计的。为什么计算机不采用原始版的洗牌算法呢？因为，在计算机中，会将很多无用的时间消耗在原始版的第三个步骤。
有两种方式是:
一、

    1. 从原始列表取出一个随机数
    2. 判断新的列表是否存在这个随机数
    3. 不存在则加入到新的列表
    4. 最后这个新列表就是随机排列的列表
该算法的复杂度为 O(n^2)；

二、

    1. 从原始列表取出一个随机数并且删除
    ２. 加入到新的列表
该算法的复杂度降到了O(n)；但问题时，当列表长度很大时，该算法的速度却慢于第一种，因为，当删除一个某个数组的元素时，计算机需要对数组的其它元素进行下标的计算，这个过程是非常耗时的！

而现在版的方法是:
**在每次迭代时把这个被取出的数字与原始列表最后的数字进行交换**。这样就将时间复杂度从 O(n^2) 减小到了 O(n)。


                1 2 3 4 5 6 7 8
    1-8     6   1 2 3 4 5 8 7       6
    1-7     2   1 7 3 4 5 8         2 6
    1–6     8   1 7 3 4 5           8 2 6
    1–5     1   5 7 3 4	            1 8 2 6
    1–4     3   5 7 4               3 1 8 2 6
    1–3     4   5 7                 4 3 1 8 2 6
    1–2     5   7                   5 4 3 1 8 2 6


## javascript代码实现

    Array.prototype.shuffle = function()
    {
        var arr = this;
        if (Array.isArray(arr))
        {
            for(var i=arr.length-1;i > 0;i--)
            {
                var randowIndex = Math.floor(Math.random()*i);
                var randowVal = arr[randowIndex];
                arr[randowIndex] = arr[i];
                arr[i] = randowVal;
            }
        }
        return arr;
    }

## 实际中的应用

### 从1-100000中随机取出500个不重复的整数？

